# class 

`struct`

![](../../image/2022-11-23-19-46-26.png)
![](../../image/2022-11-23-19-49-17.png)

`객체 정의`

![](../../image/2022-11-23-19-51-01.png)

`객체와 메모리`

![](../../image/2022-11-23-19-52-47.png)

`접근지정자와 캡슐화`

![](../../image/2022-11-23-19-57-13.png)
![](../../image/2022-11-23-19-58-13.png)

`생성자 소멸자`

![](../../image/2022-11-23-20-01-53.png)
![](../../image/2022-11-23-20-07-48.png)
![](../../image/2022-11-23-20-09-52.png)
![](../../image/2022-11-23-20-11-11.png)


# 멤버 데이터 초기화


`member initializer list vs at constructor`

![](../../image/2022-11-23-20-28-20.png)
![](../../image/2022-11-23-20-30-04.png)
![](../../image/2022-11-23-20-30-56.png)

- int같은 premitive type의 경우는 큰 차이가 없음

`should use member initializer list`

![](../../image/2022-11-23-20-35-15.png)
![](../../image/2022-11-23-20-38-46.png)
![](../../image/2022-11-23-20-39-30.png)

`member initializer list 사용시 주의사항`

![](../../image/2022-11-23-20-41-52.png)
![](../../image/2022-11-23-20-43-32.png)

`member initializer list with defualt member initializer`

![](../../image/2022-11-23-20-48-45.png)

# explicit

![](../../image/2022-11-23-20-51-45.png)
![](../../image/2022-11-23-20-53-46.png)
![](../../image/2022-11-23-20-57-28.png)
![](../../image/2022-11-23-20-59-18.png)
![](../../image/2022-11-23-21-01-15.png)


# 복사생성자

![](../../image/2022-11-29-20-22-26.png)

- 사용자가 만들면 안 만든다.

![](../../image/2022-11-29-20-25-29.png)

- 원래라면 아래 4개는 복사생성자가 호출됨. 하지만 explicit 키워드를 복사생성자에 넣었기 때문에 복사초기화는 불가능 -> 아래 두개 컴파일 에러

![](../../image/2022-11-29-20-28-26.png)
![](../../image/2022-11-29-20-31-13.png)

`얕은 복사`

![](../../image/2022-11-29-20-39-14.png)

`깊은 복사`

![](../../image/2022-11-29-20-41-33.png)

`ref count`

![](../../image/2022-11-29-20-45-54.png)

- 멀티스레드 환경에서 깊은 복사보다 더 성능이 안 좋을 수 있다.

`복사생성자 사용 못하게`

![](../../image/2022-11-29-20-48-40.png)

`문자열의 경우 걍 string 사용`

![](../../image/2022-11-29-20-51-34.png)

# static

![](../../image/2022-12-01-20-50-24.png)
![](../../image/2022-12-01-20-52-42.png)
![](../../image/2022-12-01-20-54-46.png)

![](../../image/2022-12-01-20-56-42.png)

- 접근지정자를 사용할 수 있는 전역변수 느낌이라 볼 수 있다.

![](../../image/2022-12-01-20-59-12.png)
![](../../image/2022-12-01-21-01-25.png)
![](../../image/2022-12-01-21-03-03.png)
![](../../image/2022-12-01-21-06-24.png)
![](../../image/2022-12-01-21-07-12.png)
![](../../image/2022-12-01-21-09-16.png)
![](../../image/2022-12-01-21-11-08.png)
![](../../image/2022-12-01-21-11-50.png)

# this


![](../../image/2022-12-12-19-35-14.png)
![](../../image/2022-12-12-19-36-16.png)
![](../../image/2022-12-12-19-38-29.png)
![](../../image/2022-12-12-19-41-38.png)

# return by valu? ref?

![](../../image/2022-12-12-19-46-04.png)

- 참조 리턴은 임시객체 만들고 파괴하는 과정이 없음

![](../../image/2022-12-12-19-48-35.png)

![](../../image/2022-12-12-19-50-18.png)

- 참조 리턴하면 의도한 대로 나옴


# const 

![](../../image/2022-12-12-20-03-10.png)
![](../../image/2022-12-12-20-04-30.png)

- 선언부에만 붙이면 const함수 안 붙인 걸로 작동함

![](../../image/2022-12-12-20-08-39.png)

![](../../image/2022-12-12-20-12-35.png)
![](../../image/2022-12-12-20-15-15.png)

- 이런 구조로 만든 이유는 상수객체와 비 상수 객체에 대해 내부 로직이나 리턴값을 다르게 하여 다르게 동작시키기 위함