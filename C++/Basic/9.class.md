# class 

`struct`

![](../../image/2022-11-23-19-46-26.png)
![](../../image/2022-11-23-19-49-17.png)

`객체 정의`

![](../../image/2022-11-23-19-51-01.png)

`객체와 메모리`

![](../../image/2022-11-23-19-52-47.png)

`접근지정자와 캡슐화`

![](../../image/2022-11-23-19-57-13.png)
![](../../image/2022-11-23-19-58-13.png)

`생성자 소멸자`

![](../../image/2022-11-23-20-01-53.png)
![](../../image/2022-11-23-20-07-48.png)
![](../../image/2022-11-23-20-09-52.png)
![](../../image/2022-11-23-20-11-11.png)


# 멤버 데이터 초기화


`member initializer list vs at constructor`

![](../../image/2022-11-23-20-28-20.png)
![](../../image/2022-11-23-20-30-04.png)
![](../../image/2022-11-23-20-30-56.png)

- int같은 premitive type의 경우는 큰 차이가 없음

`should use member initializer list`

![](../../image/2022-11-23-20-35-15.png)
![](../../image/2022-11-23-20-38-46.png)
![](../../image/2022-11-23-20-39-30.png)

`member initializer list 사용시 주의사항`

![](../../image/2022-11-23-20-41-52.png)
![](../../image/2022-11-23-20-43-32.png)

`member initializer list with defualt member initializer`

![](../../image/2022-11-23-20-48-45.png)

# explicit

![](../../image/2022-11-23-20-51-45.png)
![](../../image/2022-11-23-20-53-46.png)
![](../../image/2022-11-23-20-57-28.png)
![](../../image/2022-11-23-20-59-18.png)
![](../../image/2022-11-23-21-01-15.png)


# 복사생성자

![](../../image/2022-11-29-20-22-26.png)

- 사용자가 만들면 안 만든다.

![](../../image/2022-11-29-20-25-29.png)

- 원래라면 아래 4개는 복사생성자가 호출됨. 하지만 explicit 키워드를 복사생성자에 넣었기 때문에 복사초기화는 불가능 -> 아래 두개 컴파일 에러

![](../../image/2022-11-29-20-28-26.png)
![](../../image/2022-11-29-20-31-13.png)

`얕은 복사`

![](../../image/2022-11-29-20-39-14.png)

`깊은 복사`

![](../../image/2022-11-29-20-41-33.png)

`ref count`

![](../../image/2022-11-29-20-45-54.png)

- 멀티스레드 환경에서 깊은 복사보다 더 성능이 안 좋을 수 있다.

`복사생성자 사용 못하게`

![](../../image/2022-11-29-20-48-40.png)

`문자열의 경우 걍 string 사용`

![](../../image/2022-11-29-20-51-34.png)