# default parameter

- 컴파일할때 인자를 채워준다. 즉, 3개의 인자중 default parameter 2개를 제외하고 하나만 던진다 해서 성능이 좋은게 아니다. 어셈블리로 보면 3개를 던지는 것과 코드가 동일하다.

# function overloading

![](../../image/2022-11-07-20-04-52.png)

![](../../image/2022-11-07-20-09-30.png)

- f3의 경우 아예 만드는 것 자체가 안 된다.
- f4의 경우 저렇게 만드는 것은 문제 없지만, 모호한 호출 부를 적으면 컴파일에서 에러난다.
- f5도 f4와 마찬가지다.

![](../../image/2022-11-07-20-14-09.png)

원리는 컴파일 타임에 함수 이름은 변경 해 주는 것이다. 컴파일 마다 이름 변경 방식은 다르며 그렇기에 c와 c++ 언어 사이에 호환성 문제가 있다.

`호환성`

![](../../image/2022-11-07-20-26-43.png)
![](../../image/2022-11-07-20-28-31.png)

- c의 경우 name mangling이 일어나지 않음.

![](../../image/2022-11-07-20-41-30.png)

- 그런데  extern c 의 경우 c++의 문법이기 때문에 using_square.cpp를 .c로 바꾸면 컴파일 에러가 난다. 당연히 extern c를 제거해주면 문제가 없는데, 문제는 이 헤더를 cpp에서도 가져다 사용하고 c에서도 가져다 사용할 수 있다는 점이다. 그래서 이 경우에는 조건부 컴파일을 해야 한다.

![](../../image/2022-11-07-20-46-05.png)

# functino template

![](../../image/2022-11-07-20-54-24.png)

![](../../image/2022-11-07-20-57-15.png)

- 만약 템플릿을 사용하지 않는다면 인스턴스화가 되지 않는다. 실제 함수는 생성되지 않는다.
- 같은 type으로 한번 만들었다면 또 만들지 않는다. 

![](../../image/2022-11-07-21-02-35.png)

- 이런 경우 줄이는 방법은 명시적으로 int를 만들어 사용하는 것이다.

![](../../image/2022-11-07-21-06-25.png)

- typename 대신 class도 사용 가능하다. 둘이 완전 동일하다. auto를 사용해서도 템플릿 기능을 이용할 수 있지만 제한점이 있다.

![](../../image/2022-11-07-21-08-47.png)

- 틀은 코드 메모리에 없다. 컴파일할때 사용하는 것 뿐이다.

# inline function

![](../../image/2022-11-07-21-12-51.png)

- 엥.. 그런데 왜 같노 inline 치환이 전혀 안 된 느낌이다. inline 적었다고 무조건 적용되는 것이 아니라, 최적화 옵션을 주거나, inline을 켜 주는 옵션을 줘야 한다.(g++의 경우엔 최적화 옵션만 존재 하는 듯)

![](../../image/2022-11-07-21-16-01.png)

- 옵션을 줘서 컴파일 해보니 치환 된 것 뿐만 아니라. add2 함수의 기계어 조차 생성이 안 됐다.

![](../../image/2022-11-07-21-20-17.png)

- 단, 함수 포인터를 이용하거나 하는 부분이 있으면 코드가 메모리 어딘가에 있어야 하므로 생성된다.

![](../../image/2022-11-07-21-18-18.png)


# linkage

![](../../image/2022-11-07-21-50-49.png)

- 이렇게 빌드하면 링크까지 되서 하나의 실행파일이 나오는듯?

![](../../image/2022-11-07-21-38-13.png)

- 두 cpp 파일을 컴파일 하면 add2와 add3의 경우 에러가 난다.(h 파일은 포함되는 것이기 때문에 컴파일 대상이 아니다)

![](../../image/2022-11-07-21-41-24.png)

- add2의 경우에는 기계어 코드로 치환 되야 하는데 구현을 모르기 때문에 에러가 난다. add3의 경우에는 템플릿을 사용했으므로 함수를 인스턴스화 해야 하는데 구현부가 없으므로 에러가 난다. (둘다 그래도 희망을 품고 링크단계까지 갔다가 에러가 난다.)

- 해결 방법은 구현 자체를 헤더에 넣어야 한다.

![](../../image/2022-11-07-21-49-02.png)

# suffix return type
![](../../image/2022-11-09-19-34-15.png)

![](../../image/2022-11-09-19-36-22.png)

![](../../image/2022-11-09-19-38-34.png)

![](../../image/2022-11-09-19-40-13.png)

- 어? 이러면 14부터는 필요 없어진거 아님? 또 필요한 경우들이 있다.

# delete function 

![](../../image/2022-11-09-19-44-28.png)
![](../../image/2022-11-09-19-44-55.png)